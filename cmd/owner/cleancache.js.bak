import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { exec } from 'child_process';
import { promisify } from 'util';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const execPromise = promisify(exec);

class SystemCleaner {
    constructor() {
        this.targetFolders = [
            './tmp',
            './temp',
            './sessions/pre-key',
            './.cache'
        ];

        this.junkExtensions = [
            '.log',
            '.tmp',
            '.bak',
            '.old'
        ];
    }

    formatSize(bytes) {
        if (bytes === 0) return '0 B';
        
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    async cleanDirectory(dirPath) {
        let deletedCount = 0;
        let freedSpace = 0;

        const absolutePath = path.resolve(dirPath);
        if (!fs.existsSync(absolutePath)) {
            return { count: 0, size: 0 };
        }

        try {
            const files = await fs.promises.readdir(absolutePath);
            
            for (const file of files) {
                const curPath = path.join(absolutePath, file);
                const stat = await fs.promises.stat(curPath);

                if (stat.isDirectory()) {
                    const subResult = await this.cleanDirectory(curPath);
                    deletedCount += subResult.count;
                    freedSpace += subResult.size;
                    
                    try {
                        await fs.promises.rmdir(curPath);
                    } catch {}
                } else {
                    freedSpace += stat.size;
                    await fs.promises.unlink(curPath);
                    deletedCount++;
                }
            }
        } catch (e) {
            console.error(`[Cleaner] Skip ${dirPath}: ${e.message}`);
        }

        return { count: deletedCount, size: freedSpace };
    }

    async cleanLogs() {
        let count = 0;
        let size = 0;
        const rootDir = process.cwd();

        const files = await fs.promises.readdir(rootDir);
        
        for (const file of files) {
            if (file.endsWith('.log') || file.includes('npm-debug')) {
                const curPath = path.join(rootDir, file);
                const stat = await fs.promises.stat(curPath);
                
                size += stat.size;
                await fs.promises.unlink(curPath);
                count++;
            }
        }
        
        return { count, size };
    }

    runGarbageCollector() {
        try {
            if (global.gc) {
                global.gc();
                return true;
            }
        } catch (e) {}
        
        return false;
    }
}

let handler = async (m, { conn, reply, isOwner }) => {
    if (!isOwner) {
        return reply('ðŸ”’ *Access Denied*\nFitur ini khusus untuk Owner Bot karena mempengaruhi sistem server.');
    }

    const cleaner = new SystemCleaner();
    const memBefore = process.memoryUsage().rss;
    
    reply('[SYSTEM CLEANUP STARTED]\n\nSedang memindai file sampah, cache, dan log error...');

    try {
        let totalFiles = 0;
        let totalSize = 0;

        const tmpClean = await cleaner.cleanDirectory('./tmp');
        totalFiles += tmpClean.count;
        totalSize += tmpClean.size;

        const logClean = await cleaner.cleanLogs();
        totalFiles += logClean.count;
        totalSize += logClean.size;

        // Opsional: Bersihkan cache Playwright (uncomment jika perlu)
        const cachePath = path.resolve(process.env.HOME || '', '.cache/ms-playwright');
        /*
        if (fs.existsSync(cachePath)) {
            const cacheClean = await cleaner.cleanDirectory(cachePath);
            totalFiles += cacheClean.count;
            totalSize += cacheClean.size;
        }
        */

        const gcStatus = cleaner.runGarbageCollector();
        const memAfter = process.memoryUsage().rss;
        const memFreed = memBefore - memAfter;

        const caption = `[MAINTENANCE REPORT]\n` +
                       `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n` +
                       `Files Deleted: ${totalFiles} Files\n` +
                       `Storage Freed: ${cleaner.formatSize(totalSize)}\n` +
                       `RAM Usage: ${cleaner.formatSize(memAfter)}\n` +
                       `RAM Freed: ${memFreed > 0 ? cleaner.formatSize(memFreed) : 'Optimized'}\n` +
                       `GC Status: ${gcStatus ? 'Forced' : 'Auto'}\n` +
                       `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n` +
                       `Bot kini berjalan lebih ringan!`;

        await conn.sendMessage(m.chat, { 
            text: caption,
            contextInfo: {
                externalAdReply: {
                    title: "System Optimized",
                    body: "Server Performance Status",
                    thumbnailUrl: "https://img.icons8.com/3d-fluency/94/rocket.png",
                    sourceUrl: "https://github.com/liwirya",
                    mediaType: 1,
                    renderLargerThumbnail: true
                }
            } 
        }, { quoted: m });

    } catch (e) {
        console.error('[Cleanup Error]', e);
        reply(`[System Error]:\n${e.message}`);
    }
};

handler.help = ['clearcache', 'cleartmp', 'cleaner'];
handler.tags = ['owner'];
handler.command = /^(clearcache|cleartmp|cleaner|cs)$/i;
handler.owner = true;

export default handler;